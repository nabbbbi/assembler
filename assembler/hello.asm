	%include "stud_io.inc" 	; Its a directive / file that told assembler implace it with all code that written within. This file written in assembler too. This pariticular file include macroses PRINT, PUTCHAR, FINISH. When assembler see this directive, he remember and became able use this macros until program's end
	global _start 		;  its a directive that let label been seeing out of object module. Been seeing for OC, in particular that provide possibility to do point of start. with that directive assembler put in program information about label _start not only visible out of box, but visible for linker , in second stady of compile

	section .text 		; in executable file of UNIX machine commands store in 1 part, initialized date stores in other part and information about memory, that we must have, to store uninitialized data in 3rd part. This parts called Sections. And when  executable file loading, OS create spaces of memory, called Segments,1) for machine code, that will store all code from 1st Section of executable file(with machine command),2) for data (here bound initialized and uninitilized data), 3) for stack (do not require any section from executable file). And when we write section and yada yada, we prepare section for loading in prospective. Sections can be '.text' for executable code, '.data' for ititialized data and '.bss' that how mush memory we need for unitialized data
_start:	mov eax, 0 		; move means move some data from one place to second place. In particular, first operand means where should place data, second operand means what data we should move. In a nutshell, we change value of eax register to 0 for using it as counting of circles. And _start is label that denote address(hexadecimal address,for example 18b4a0f0) of cell as starts in RAM machine command mov eax, 0 (b8 00 00 00 00). In particular, _start is a label that mean point of begin program that tells OC where should place management after loading program in RAM.
again:	PRINT "Hello" 		; again is label that means "return here". PRINT is macros that present in stud_io.inc file. "Hello" is his paramater. this line is directive, not a command, alse known as macrocall. When assembler see this macrocall he create yourself assembler code and call to OC for execute.
	PUTCHAR 10		;  macrocal that print cymbol #10 means put cursor in next line. also as we can use 1byte registers: AL, AH, BL, BH, CL, CH, DL, DH. And complementary adress in curly brackets means address of cell with code of symbol
	inc eax 		; simple increasing eax register by 1. we print 'hello', went in the next line and we ready to do this again
	cmp eax,5 		; comparison value of eax and value 5. Result of this comparison records in special register, that called register of flags. in depend of this result we would do conditional jump
	jl again 		;  this is another mnemonic (mnemonic is short word denoting machine command). In particular, this is conditional jump that mean 'jump if less' , if precursor comparison give result as 'first operand less than second' than do command that present next after jl
	FINISH 			;  macrocall to OS that invoke about ending this program. big programs divide in modules. outer procuders called libraries. When we compile modules we get object modules. Next we should do is compile all object modules and libraries in machine code. For that busyness we need linker. To compile nasm -f elf [name].asm. elf means exucutable and linkable format. Thank link with linker ld 'ld [name].o -o [name]'. program [name] ready for use. If we using 64 bin vesion OC should add next string while linking 'ld -m elf_i386 [name].o -o [name]'. -o mean output
